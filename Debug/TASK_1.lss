
TASK_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000264  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00000264  000002f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000a  00800066  00800066  000002fe  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000002fe  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000330  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000070  00000000  00000000  0000036c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000a20  00000000  00000000  000003dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000749  00000000  00000000  00000dfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000552  00000000  00000000  00001545  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000120  00000000  00000000  00001a98  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000448  00000000  00000000  00001bb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000381  00000000  00000000  00002000  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000088  00000000  00000000  00002381  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 f2 00 	jmp	0x1e4	; 0x1e4 <__vector_16>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 e6       	ldi	r30, 0x64	; 100
  68:	f2 e0       	ldi	r31, 0x02	; 2
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a6 36       	cpi	r26, 0x66	; 102
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a6 e6       	ldi	r26, 0x66	; 102
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a0 37       	cpi	r26, 0x70	; 112
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 5e 00 	call	0xbc	; 0xbc <main>
  8a:	0c 94 30 01 	jmp	0x260	; 0x260 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <func1>:
int x;


void func1(void)
{
	x = 1;
  92:	81 e0       	ldi	r24, 0x01	; 1
  94:	90 e0       	ldi	r25, 0x00	; 0
  96:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <x+0x1>
  9a:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <x>
  9e:	08 95       	ret

000000a0 <func2>:
}

void func2(void)
{
	x = 2;
  a0:	82 e0       	ldi	r24, 0x02	; 2
  a2:	90 e0       	ldi	r25, 0x00	; 0
  a4:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <x+0x1>
  a8:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <x>
  ac:	08 95       	ret

000000ae <func3>:
}

void func3(void)
{
	x = 3;
  ae:	83 e0       	ldi	r24, 0x03	; 3
  b0:	90 e0       	ldi	r25, 0x00	; 0
  b2:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <x+0x1>
  b6:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <x>
  ba:	08 95       	ret

000000bc <main>:
}

int main ()
{
  bc:	cf 93       	push	r28
  be:	df 93       	push	r29
  c0:	cd b7       	in	r28, 0x3d	; 61
  c2:	de b7       	in	r29, 0x3e	; 62
  c4:	66 97       	sbiw	r28, 0x16	; 22
  c6:	0f b6       	in	r0, 0x3f	; 63
  c8:	f8 94       	cli
  ca:	de bf       	out	0x3e, r29	; 62
  cc:	0f be       	out	0x3f, r0	; 63
  ce:	cd bf       	out	0x3d, r28	; 61
	SREG |= 1 << I;
  d0:	8f b7       	in	r24, 0x3f	; 63
  d2:	80 68       	ori	r24, 0x80	; 128
  d4:	8f bf       	out	0x3f, r24	; 63
	u16 myResult[3] = {0};
  d6:	ce 01       	movw	r24, r28
  d8:	01 96       	adiw	r24, 0x01	; 1
  da:	26 e0       	ldi	r18, 0x06	; 6
  dc:	fc 01       	movw	r30, r24
  de:	11 92       	st	Z+, r1
  e0:	2a 95       	dec	r18
  e2:	e9 f7       	brne	.-6      	; 0xde <main+0x22>
	u8 myChannel[3] = {0,1,2};
  e4:	1f 82       	std	Y+7, r1	; 0x07
  e6:	21 e0       	ldi	r18, 0x01	; 1
  e8:	28 87       	std	Y+8, r18	; 0x08
  ea:	22 e0       	ldi	r18, 0x02	; 2
  ec:	29 87       	std	Y+9, r18	; 0x09
	void (*(funArr[3]))(void) = {func1,func2,func3};
  ee:	26 e0       	ldi	r18, 0x06	; 6
  f0:	e0 e6       	ldi	r30, 0x60	; 96
  f2:	f0 e0       	ldi	r31, 0x00	; 0
  f4:	de 01       	movw	r26, r28
  f6:	1a 96       	adiw	r26, 0x0a	; 10
  f8:	01 90       	ld	r0, Z+
  fa:	0d 92       	st	X+, r0
  fc:	2a 95       	dec	r18
  fe:	e1 f7       	brne	.-8      	; 0xf8 <main+0x3c>
	
	ADC_Chain myChain = {3,myResult,myChannel,funArr};
 100:	23 e0       	ldi	r18, 0x03	; 3
 102:	28 8b       	std	Y+16, r18	; 0x10
 104:	9a 8b       	std	Y+18, r25	; 0x12
 106:	89 8b       	std	Y+17, r24	; 0x11
 108:	06 96       	adiw	r24, 0x06	; 6
 10a:	9c 8b       	std	Y+20, r25	; 0x14
 10c:	8b 8b       	std	Y+19, r24	; 0x13
 10e:	03 96       	adiw	r24, 0x03	; 3
 110:	9e 8b       	std	Y+22, r25	; 0x16
 112:	8d 8b       	std	Y+21, r24	; 0x15
	ADC_init();
 114:	0e 94 92 00 	call	0x124	; 0x124 <ADC_init>
	ADC_StartConvAsync_chain(&myChain);
 118:	ce 01       	movw	r24, r28
 11a:	40 96       	adiw	r24, 0x10	; 16
 11c:	0e 94 a3 00 	call	0x146	; 0x146 <ADC_StartConvAsync_chain>
	
	while (1)
	{
		while (ADCSRA & (1 << ADIF))
 120:	86 b1       	in	r24, 0x06	; 6
 122:	fe cf       	rjmp	.-4      	; 0x120 <main+0x64>

00000124 <ADC_init>:
	{
		ADC_Error_Status = NOK;
	}
	State = IDLE;
	return ADC_Error_Status;
}
 124:	87 b1       	in	r24, 0x07	; 7
 126:	8f 73       	andi	r24, 0x3F	; 63
 128:	80 64       	ori	r24, 0x40	; 64
 12a:	87 b9       	out	0x07, r24	; 7
 12c:	87 b1       	in	r24, 0x07	; 7
 12e:	80 62       	ori	r24, 0x20	; 32
 130:	97 b1       	in	r25, 0x07	; 7
 132:	89 2b       	or	r24, r25
 134:	87 b9       	out	0x07, r24	; 7
 136:	86 b1       	in	r24, 0x06	; 6
 138:	88 7f       	andi	r24, 0xF8	; 248
 13a:	81 60       	ori	r24, 0x01	; 1
 13c:	86 b9       	out	0x06, r24	; 6
 13e:	86 b1       	in	r24, 0x06	; 6
 140:	80 68       	ori	r24, 0x80	; 128
 142:	86 b9       	out	0x06, r24	; 6
 144:	08 95       	ret

00000146 <ADC_StartConvAsync_chain>:


Error_Status ADC_StartConvAsync_chain(ADC_Chain* chain)
{
	Error_Status ADC_Error_Status = OK;
	if (State == SYNC_BUSY)
 146:	20 91 69 00 	lds	r18, 0x0069	; 0x800069 <State>
 14a:	21 30       	cpi	r18, 0x01	; 1
 14c:	09 f4       	brne	.+2      	; 0x150 <ADC_StartConvAsync_chain+0xa>
 14e:	46 c0       	rjmp	.+140    	; 0x1dc <ADC_StartConvAsync_chain+0x96>
	{
		ADC_Error_Status = NOK;
	}
	else
	{
		State = CHAIN_BUSY;
 150:	22 e0       	ldi	r18, 0x02	; 2
 152:	20 93 69 00 	sts	0x0069, r18	; 0x800069 <State>
		static u8 count = 0;
		Chain_global = chain;
 156:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <Chain_global+0x1>
 15a:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <Chain_global>
		if (count < chain->length)
 15e:	dc 01       	movw	r26, r24
 160:	3c 91       	ld	r19, X
 162:	20 91 66 00 	lds	r18, 0x0066	; 0x800066 <__data_end>
 166:	23 17       	cp	r18, r19
 168:	a8 f5       	brcc	.+106    	; 0x1d4 <ADC_StartConvAsync_chain+0x8e>
		{
			if(chain->channel[count] > channel_7)
 16a:	13 96       	adiw	r26, 0x03	; 3
 16c:	ed 91       	ld	r30, X+
 16e:	fc 91       	ld	r31, X
 170:	14 97       	sbiw	r26, 0x04	; 4
 172:	30 e0       	ldi	r19, 0x00	; 0
 174:	e2 0f       	add	r30, r18
 176:	f3 1f       	adc	r31, r19
 178:	40 81       	ld	r20, Z
 17a:	48 30       	cpi	r20, 0x08	; 8
 17c:	88 f5       	brcc	.+98     	; 0x1e0 <ADC_StartConvAsync_chain+0x9a>
			{
				ADC_Error_Status = NOK;
			}
			else
			{
				ADC_Result = &(chain->result[count]);
 17e:	11 96       	adiw	r26, 0x01	; 1
 180:	4d 91       	ld	r20, X+
 182:	5c 91       	ld	r21, X
 184:	12 97       	sbiw	r26, 0x02	; 2
 186:	22 0f       	add	r18, r18
 188:	33 1f       	adc	r19, r19
 18a:	42 0f       	add	r20, r18
 18c:	53 1f       	adc	r21, r19
 18e:	50 93 68 00 	sts	0x0068, r21	; 0x800068 <ADC_Result+0x1>
 192:	40 93 67 00 	sts	0x0067, r20	; 0x800067 <ADC_Result>
				ADC_END = chain->ptrToPtrToFun[count];
 196:	15 96       	adiw	r26, 0x05	; 5
 198:	8d 91       	ld	r24, X+
 19a:	9c 91       	ld	r25, X
 19c:	16 97       	sbiw	r26, 0x06	; 6
 19e:	dc 01       	movw	r26, r24
 1a0:	a2 0f       	add	r26, r18
 1a2:	b3 1f       	adc	r27, r19
 1a4:	8d 91       	ld	r24, X+
 1a6:	9c 91       	ld	r25, X
 1a8:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <ADC_END+0x1>
 1ac:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <ADC_END>
				/***********  SET ADC CHANNEL  ************/
				//HDIO_SetPinDirection_vid(A,chain->channel[count],INPUT);
				u8 Local = ADMUX;
 1b0:	87 b1       	in	r24, 0x07	; 7
				Local &= CLR_CHANNEL;
 1b2:	80 7e       	andi	r24, 0xE0	; 224
				Local |= (chain->channel[count] << MUX0);
 1b4:	90 81       	ld	r25, Z
 1b6:	89 2b       	or	r24, r25
				ADMUX = Local;
 1b8:	87 b9       	out	0x07, r24	; 7
				/********** ENABLE ADC INTERRUPT **********/
				ADCSRA |= (1 << ADIE);
 1ba:	86 b1       	in	r24, 0x06	; 6
 1bc:	88 60       	ori	r24, 0x08	; 8
 1be:	86 b9       	out	0x06, r24	; 6
				/***********  START CONVERSION ************/
				ADCSRA |= (1 << ADSC);
 1c0:	86 b1       	in	r24, 0x06	; 6
 1c2:	80 64       	ori	r24, 0x40	; 64
 1c4:	86 b9       	out	0x06, r24	; 6
				count++;
 1c6:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <__data_end>
 1ca:	8f 5f       	subi	r24, 0xFF	; 255
 1cc:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__data_end>
}*/


Error_Status ADC_StartConvAsync_chain(ADC_Chain* chain)
{
	Error_Status ADC_Error_Status = OK;
 1d0:	80 e0       	ldi	r24, 0x00	; 0
 1d2:	08 95       	ret
			}
		}
		else
		{
			ADC_Error_Status = FINISH;
			State = IDLE;
 1d4:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <State>
				count++;
			}
		}
		else
		{
			ADC_Error_Status = FINISH;
 1d8:	82 e0       	ldi	r24, 0x02	; 2
 1da:	08 95       	ret
Error_Status ADC_StartConvAsync_chain(ADC_Chain* chain)
{
	Error_Status ADC_Error_Status = OK;
	if (State == SYNC_BUSY)
	{
		ADC_Error_Status = NOK;
 1dc:	81 e0       	ldi	r24, 0x01	; 1
 1de:	08 95       	ret
		Chain_global = chain;
		if (count < chain->length)
		{
			if(chain->channel[count] > channel_7)
			{
				ADC_Error_Status = NOK;
 1e0:	81 e0       	ldi	r24, 0x01	; 1
			ADC_Error_Status = FINISH;
			State = IDLE;
		}
	}
	return ADC_Error_Status;
}
 1e2:	08 95       	ret

000001e4 <__vector_16>:

ISR(ADC_vect)
{
 1e4:	1f 92       	push	r1
 1e6:	0f 92       	push	r0
 1e8:	0f b6       	in	r0, 0x3f	; 63
 1ea:	0f 92       	push	r0
 1ec:	11 24       	eor	r1, r1
 1ee:	2f 93       	push	r18
 1f0:	3f 93       	push	r19
 1f2:	4f 93       	push	r20
 1f4:	5f 93       	push	r21
 1f6:	6f 93       	push	r22
 1f8:	7f 93       	push	r23
 1fa:	8f 93       	push	r24
 1fc:	9f 93       	push	r25
 1fe:	af 93       	push	r26
 200:	bf 93       	push	r27
 202:	ef 93       	push	r30
 204:	ff 93       	push	r31
	#if Adjust_Result == LeftAdjustResult
	*ADC_Result = (u16)(ADCL >> 6);
	*ADC_Result |= (u16)(ADCH << 2);
	#elif Adjust_Result == RightAdjustResult
	*ADC_Result = (u16)(ADCH << 8);
 206:	e0 91 67 00 	lds	r30, 0x0067	; 0x800067 <ADC_Result>
 20a:	f0 91 68 00 	lds	r31, 0x0068	; 0x800068 <ADC_Result+0x1>
 20e:	85 b1       	in	r24, 0x05	; 5
 210:	10 82       	st	Z, r1
 212:	81 83       	std	Z+1, r24	; 0x01
	*ADC_Result |= ADCL;
 214:	24 b1       	in	r18, 0x04	; 4
 216:	e0 91 67 00 	lds	r30, 0x0067	; 0x800067 <ADC_Result>
 21a:	f0 91 68 00 	lds	r31, 0x0068	; 0x800068 <ADC_Result+0x1>
 21e:	80 81       	ld	r24, Z
 220:	91 81       	ldd	r25, Z+1	; 0x01
 222:	82 2b       	or	r24, r18
 224:	91 83       	std	Z+1, r25	; 0x01
 226:	80 83       	st	Z, r24
	#endif
	ADC_END();
 228:	e0 91 6c 00 	lds	r30, 0x006C	; 0x80006c <ADC_END>
 22c:	f0 91 6d 00 	lds	r31, 0x006D	; 0x80006d <ADC_END+0x1>
 230:	09 95       	icall
	ADC_StartConvAsync_chain(Chain_global);
 232:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <Chain_global>
 236:	90 91 6f 00 	lds	r25, 0x006F	; 0x80006f <Chain_global+0x1>
 23a:	0e 94 a3 00 	call	0x146	; 0x146 <ADC_StartConvAsync_chain>
 23e:	ff 91       	pop	r31
 240:	ef 91       	pop	r30
 242:	bf 91       	pop	r27
 244:	af 91       	pop	r26
 246:	9f 91       	pop	r25
 248:	8f 91       	pop	r24
 24a:	7f 91       	pop	r23
 24c:	6f 91       	pop	r22
 24e:	5f 91       	pop	r21
 250:	4f 91       	pop	r20
 252:	3f 91       	pop	r19
 254:	2f 91       	pop	r18
 256:	0f 90       	pop	r0
 258:	0f be       	out	0x3f, r0	; 63
 25a:	0f 90       	pop	r0
 25c:	1f 90       	pop	r1
 25e:	18 95       	reti

00000260 <_exit>:
 260:	f8 94       	cli

00000262 <__stop_program>:
 262:	ff cf       	rjmp	.-2      	; 0x262 <__stop_program>
